<?php

class WC_Bookings_Custom extends WC_Bookings {
	public function __construct() {
		parent::includes();
	}
}

// Ensure that WooCommerce Bookings class files are included
new WC_Bookings_Custom;

class WC_Booking_Extensions_Product_Booking extends WC_Product_Booking {

	/**
	 * WC_Booking_Extensions_Product_Booking constructor.
	 *
	 * @param int $product
	 */
	public function __construct( $product = 0 ) {
		$this->defaults['block_starts'] = 'on_the_half_hour';
		if ( is_integer( intval( $product ) ) ) {
			$product = wc_get_product( $product );
		}
		parent::__construct( $product );
		if ( is_a( $product, 'WC_Product' ) ) {
			$this->data['block_starts'] = $product->get_meta( 'block_starts' );
		}
	}

	/**
	 * Returns blocks/time slots from a given start and end minute blocks.
	 *
	 * This function take varied inputs but always returns a block array of available slots.
	 * Sometimes it gets the minutes and see if all is available some times it needs to make up the
	 * minutes based on what is booked.
	 *
	 * It uses start and end date to figure things out.
	 *
	 * @param $check_date
	 * @param $start_date
	 * @param $end_date
	 * @param $bookable_ranges
	 * @param $intervals
	 * @param integer $resource_id
	 * @param $minutes_not_available
	 *
	 * @return array
	 */

	protected function get_bookable_minute_blocks_for_date( $check_date, $start_date, $end_date, $bookable_ranges, $intervals, $resource_id, $minutes_not_available ) {
		switch ( $this->data['block_starts'] ) {
			case 'on_the_hour':
				$intervals[1] = 60;
				break;
			case 'on_the_half_hour':
				$intervals[1] = 30;
				break;
			case 'on_the_quarter':
				$intervals[1] = 15;
				break;
		}

		// blocks as in an array of slots. $slot_start_times
		$blocks = array();

		// boring interval stuff
		$interval      = $intervals[0];
		$base_interval = $intervals[1];

		// get a time stamp to check from
		// and get a time stamp to check to
		$product_min_date = $this->get_min_date();
		$product_max_date = $this->get_max_date();
		if ( 'hour' === $product_min_date['unit'] ) {
			// Adding 1 hour to round up to the next whole hour to return what is expected.
			$product_min_date['value'] = (int) $product_min_date['value'] + 1;
		}

		$min_check_from = strtotime( "+{$product_min_date['value']} {$product_min_date['unit']}", current_time( 'timestamp' ) );
		$max_check_to   = strtotime( "+{$product_max_date['value']} {$product_max_date['unit']}", current_time( 'timestamp' ) );
		$min_date       = wc_bookings_get_min_timestamp_for_day( $start_date, $product_min_date['value'], $product_min_date['unit'] );

		$available_qty      = $this->get_available_quantity( $resource_id );
		$current_time_stamp = current_time( 'timestamp' );
		$availability       = $this->get_default_availability();

		// Loop ranges looking for slots within
		foreach ( $bookable_ranges as $minutes ) {
			$range_start = $minutes[0];
			$range_end   = $minutes[1];
			if ( 'hour' === $this->get_duration_unit() ) {
				// Adding 1 minute to round up to a full hour.
				$range_end++;
			}

			$range_start_time        = strtotime( "midnight +{$range_start} minutes", $check_date );
			$range_end_time          = strtotime( "midnight +{$range_end} minutes", $check_date );
			$minutes_for_range       = $range_end - $range_start;
			$base_intervals_in_block = floor( $minutes_for_range / $base_interval );

			// Only start blocks on $base_interval (on the hour, on the half hour or on the quarter)
			$block_start      = intval( gmdate( 'i', $range_start_time ) );
			$adj              = $block_start % $base_interval;
			$range_start_time = $range_start_time + ( $adj ? $adj : 0 );

			for ( $i = 0; $i <= $base_intervals_in_block; $i ++ ) {
				$from_interval = $i * $base_interval;
				$to_interval   = $from_interval + $interval;
				$start_time    = strtotime( "+{$from_interval} minutes", $range_start_time );
				$end_time      = strtotime( "+{$to_interval} minutes", $range_start_time );

				// Break if start time is after the end date being calculated.
				if ( $start_time > $end_date ) {
					break 2;
				}

				// Must be in the future
				if ( $start_time < $min_date || $start_time <= $current_time_stamp ) {
					continue;
				}

				// check that start time falls within minutes
				// and that the correct quantity
				if ( isset( $minutes_not_available[ $start_time ] ) &&
					$minutes_not_available[ $start_time ] >= $available_qty ) {
					continue;
				}

				// make sure minute & hour blocks are not past minimum & max booking settings.
				if ( $end_time < $min_check_from || $start_time > $max_check_to ) {
					continue;
				}

				if ( $end_time > $range_end_time ) {
					continue;
				}

				// make sure slot doesn't start after the end date.
				if ( $start_time > $end_date ) {
					continue;
				}

				// if default availability is NO/False then it means the minutes we're looking at has already been
				// generated by using the rules so there's no need to test availability again.
				if ( $availability &&
					! WC_Product_Booking_Rule_Manager::check_availability_rules_against_time( $start_time, $end_time, $resource_id, $this, $availability ) ) {
					continue;
				}

				if ( ! in_array( $start_time, $blocks, true ) ) {
					$blocks[] = $start_time;
				}
			}
		}

		return $blocks;
	}

	/**
	 * Get block_starts.
	 *
	 * @param  string $context
	 * @return string
	 */
	public function get_block_starts( $context = 'view' ) {
		return $this->get_prop( 'block_starts', $context );
	}
}