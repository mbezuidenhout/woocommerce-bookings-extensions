<?php

class WC_Bookings_Custom extends WC_Bookings{
	public function __construct() {
		parent::includes();
	}
}

new WC_Bookings_Custom;

class WC_Booking_Extensions_Product_Booking extends WC_Product_Booking {

	public function get_bookable_minute_blocks_for_date( $check_date, $start_date, $end_date, $bookable_ranges, $intervals, $resource_id, $minutes_not_available ) {
		$block_starts = 'on_the_half_hour';
		switch($block_starts) {
			case 'on_the_hour':
				$intervals[1] = 60;
				break;
			case 'on_the_half_hour':
				$intervals[1] = 30;
				break;
			case 'on_the_quarter':
				$intervals[1] = 15;
				break;
		}

		// blocks as in an array of slots. $slot_start_times
		$blocks = array();

		// boring interval stuff
		$interval              = $intervals[0];
		$base_interval         = $intervals[1];

		// get a time stamp to check from
		// and get a time stamp to check to
		$product_min_date = $this->get_min_date();
		$product_max_date = $this->get_max_date();
		if ( 'hour' === $product_min_date['unit'] ) {
			// Adding 1 hour to round up to the next whole hour to return what is expected.
			$product_min_date['value'] = (int) $product_min_date['value'] + 1;
		}

		$min_check_from     = strtotime( "+{$product_min_date['value']} {$product_min_date['unit']}", current_time( 'timestamp' ) );
		$max_check_to       = strtotime( "+{$product_max_date['value']} {$product_max_date['unit']}", current_time( 'timestamp' ) );
		$min_date           = wc_bookings_get_min_timestamp_for_day( $start_date, $product_min_date['value'], $product_min_date['unit'] );

		$available_qty      = $this->get_available_quantity( $resource_id );
		$current_time_stamp = current_time( 'timestamp' );
		$availability       = $this->get_default_availability();

		// if we have a buffer, we will shift all times accordingly by changing the from_interval
		// e.g. 60 min buffer shifts [ 480, 600, 720 ] into [ 480, 660, 840 ]
		$buffer = $this->get_buffer_period_minutes() ?: 0;

		// For customers using buffers _and_ customer defined time slots, include the interval
		// in the buffer so that times are shifted accordingly, if we already have a buffer.
		if ( $buffer && 'customer' == $this->get_duration_type() ) {
			$buffer += $interval;
		}

		// if adjacency is enabled, multiply the buffer by 2 (see https://docs.woocommerce.com/document/creating-a-bookable-product/#section-8)
		if ( $this->get_apply_adjacent_buffer() ) {
			$buffer *= 2;
		}

		// Loop ranges looking for slots within
		foreach ( $bookable_ranges as $minutes ) {
			$range_start = $minutes[0];
			$range_end   = $minutes[1];
			if ( 'hour' === $this->get_duration_unit() ) {
				// Adding 1 minute to round up to a full hour.
				$range_end  += 1;
			}

			$range_start_time        = strtotime( "midnight +{$range_start} minutes", $check_date );
			$range_end_time          = strtotime( "midnight +{$range_end} minutes", $check_date );
			$minutes_for_range       = $range_end - $range_start;
			$base_intervals_in_block = floor( $minutes_for_range / $base_interval );

			// Only start blocks on $base_interval (on the hour, on the half hour or on the quarter)
			$block_start = intval( gmdate( "i", $range_start_time ) );
			$adj = $block_start % $base_interval;
			$range_start_time = $range_start_time + ( $adj ? $adj : 0 );

			for ( $i = 0; $i <= $base_intervals_in_block; $i ++ ) {
				$from_interval = $i * $base_interval;
				$to_interval   = $from_interval + $interval;
				$start_time    = strtotime( "+{$from_interval} minutes", $range_start_time );
				$end_time       = strtotime( "+{$to_interval} minutes", $range_start_time );

				// Break if start time is after the end date being calculated.
				if ( $start_time > $end_date ) {
					break 2;
				}

				// Must be in the future
				if ( $start_time < $min_date || $start_time <= $current_time_stamp ) {
					continue;
				}

				// check that start time falls within minutes
				// and that the correct quantity
				if ( isset( $minutes_not_available[ $start_time ] )
				     && $minutes_not_available[ $start_time ] >= $available_qty ) {
					continue;
				}

				// make sure minute & hour blocks are not past minimum & max booking settings.
				if ( $end_time < $min_check_from || $start_time > $max_check_to ) {
					continue;
				}

				if ( $end_time > $range_end_time ) {
					continue;
				}

				// make sure slot doesn't start after the end date.
				if ( $start_time > $end_date ) {
					continue;
				}

				// if default availability is NO/False then it means the minutes we're looking at has already been
				// generated by using the rules so there's no need to test availability again.
				if ( $availability
				     && ! WC_Product_Booking_Rule_Manager::check_availability_rules_against_time( $start_time, $end_time, $resource_id, $this, $availability ) ) {
					continue;
				}

				if ( ! in_array( $start_time, $blocks ) ) {
					$blocks[] = $start_time;
				}
			}
		}

		return  $blocks;
	}
}